{"name":"Calculating Correct Compilers","tagline":"Coq proofs for the paper \"Calculating Correct Compilers\"","body":"Calculating Correct Compilers\r\n=============================\r\n\r\n[![Build Status](https://travis-ci.org/pa-ba/calc-comp.svg?branch=master)](https://travis-ci.org/pa-ba/calc-comp)\r\n\r\nThis repository contains the supplementary material for the paper\r\n[\"Calculating Correct Compilers\"](http://www.diku.dk/~paba/pubs/files/bahr14jfp-preprint.pdf)\r\nby Patrick Bahr and Graham Hutton.  The material includes Coq\r\nformalisations of all calculations in the paper. In addition, we also\r\ninclude Coq formalisations for calculations that were mentioned but\r\nnot explicitly carried out in the paper.\r\n\r\nPaper vs. Coq Proofs\r\n--------------------\r\n\r\nThe Coq proofs proceed as the calculations in the paper. There are,\r\nhowever, two minor technical difference due to the nature of the Coq\r\nsystem.\r\n\r\n  1. In the paper the derived VMs are tail recursive, first-order\r\n     functions. The Coq system must be able to prove termination of\r\n     all recursive function definitions. Since Coq's termination\r\n     checker is not powerful enough to prove termination for some of\r\n     the VMs (VMs from sections 3.1, 4.1, 5) or the VMs are not\r\n     expected to terminate in general (VMs for lambda calculi / for\r\n     language with loops), we had to define the VMs as relations\r\n     instead. In particular, all VMs are defined as a small-step\r\n     semantics. Each tail recursive function of a VM corresponds to a\r\n     configuration constructor in the small-step semantics. As a\r\n     consequence, the calculations do not prove equations, but rather\r\n     instances of the relation =>>, which is the transitive, reflexive\r\n     closure of the relation ==> that defines the VM.\r\n\r\n  2. The Coq files contain the final result of the calculation, and\r\n     thus do not reflect the *process* of discovering the definition\r\n     of the compiler and the VM. That is, the files already contain\r\n     the full definitions of the compiler and the virtual machine. But\r\n     we used the same methodology as described in the paper to\r\n     *develop* the Coq proofs. This is achieved by initially defining\r\n     the Code data type as an empty type, defining the VM relation as\r\n     an empty relation (i.e. with no rules), and defining the compiler\r\n     function using the term \"Admit\" (which corresponds to Haskell's\r\n     \"undefined\"). This setup then allows us to calculate the\r\n     definition of the Code data type, the VM, and the compiler as\r\n     described in the paper.\r\n\r\nFile Structure\r\n--------------\r\n\r\nBelow we list the relevant Coq files for the calculations in the\r\npaper:\r\n\r\n - [Arith.v](https://github.com/pa-ba/calc-comp/blob/master/Arith.v): arithmetic expressions (section 2)\r\n - [Exceptions.v](https://github.com/pa-ba/calc-comp/blob/master/Exceptions.v): exceptions, first approach (section 3.1)\r\n - [ExceptionsTwoCont.v](https://github.com/pa-ba/calc-comp/blob/master/ExceptionsTwoCont.v): exceptions, second\r\n   approach (section 3.2)\r\n - [StateGlobal.v](https://github.com/pa-ba/calc-comp/blob/master/StateGlobal.v): global state (section 4.1)\r\n - [StateLocal.v](https://github.com/pa-ba/calc-comp/blob/master/StateLocal.v): local state (section 4.2)\r\n - [Lambda.v](https://github.com/pa-ba/calc-comp/blob/master/Lambda.v): call-by-value lambda calculus (section 5)\r\n\r\nIn addition we also include calculations for the following languages:\r\n\r\n - [LambdaCBName.v](https://github.com/pa-ba/calc-comp/blob/master/LambdaCBName.v): call-by-name lambda calculus\r\n - [LambdaCBNeed.v](https://github.com/pa-ba/calc-comp/blob/master/LambdaCBNeed.v): call-by-need lambda calculus\r\n - [LambdaExceptions.v](https://github.com/pa-ba/calc-comp/blob/master/LambdaExceptions.v): call-by-value lambda\r\n   calculus with exceptions\r\n - [StateGlobalSeq.v](https://github.com/pa-ba/calc-comp/blob/master/StateGlobalSeq.v): global state with explicit\r\n   sequence operator\r\n - [Loop.v](https://github.com/pa-ba/calc-comp/blob/master/Loop.v): a simple imperative language with while loops\r\n\r\nThe remaining files are used to define the Coq tactics to support\r\nreasoning in calculation style ([Tactics.v](https://github.com/pa-ba/calc-comp/blob/master/Tactics.v)) and to specify\r\nauxiliary concepts ([Heap.v](https://github.com/pa-ba/calc-comp/blob/master/Heap.v), [ListIndex.v](https://github.com/pa-ba/calc-comp/blob/master/ListIndex.v)). We\r\nrecommend using the\r\n[generated documentation](http://pa-ba.github.io/calc-comp/doc/toc.html)\r\nto browse the Coq files.\r\n\r\nHaskell Code\r\n------------\r\n\r\nHaskell definitions of the calculated compilers from the paper can be\r\nfound in the [Haskell](https://github.com/pa-ba/calc-comp/blob/master/Haskell) sub-directory. In addtion, the\r\n[extraction](https://github.com/pa-ba/calc-comp/blob/master/extraction) sub-directory contains Haskell definitions of\r\nthe compilers generated from the Coq proofs using Coq's code\r\nextraction facility (see below).\r\n\r\nTechnical Details\r\n-----------------\r\n\r\n### Dependencies\r\n\r\n- To check the proofs: Coq 8.4pl5\r\n- To step through the proofs: GNU Emacs 24.3.1, Proof General 4.2\r\n\r\n### Proof Checking\r\n\r\nTo check and compile the complete Coq development, you can use the\r\n`Makefile`:\r\n\r\n```shell\r\n> make\r\n```\r\n\r\n### Code Extraction\r\n\r\nThe Haskell definitions in the sub-directory [extraction](https://github.com/pa-ba/calc-comp/blob/master/extraction)\r\nhave be obtained by code extraction. The code extraction can be\r\nrepeated as follows:\r\n\r\n```shell\r\n> make\r\n> cd extraction\r\n> make\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}